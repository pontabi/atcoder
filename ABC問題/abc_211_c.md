# 解法

動的計画法を使う

例えば、"abcabc"という文字列から、左から順に一文字づつ選ぶ
`S = "abcabc"`とすると、
S[0]の時点で

- "a"を作れる場合の数は、1
- "ab"を作れる場合の数は、0
- "abc"を作れる場合の数は、0
  S[1]の時点で
- "a"を作れる場合の数は、1
- "ab"を作れる場合の数は、1
- "abc"を作れる場合の数は、0
  S[2]の時点で
- "a"を作れる場合の数は、1
- "ab"を作れる場合の数は、1
- "abc"を作れる場合の数は、1
  S[3]の時点で
- "a"を作れる場合の数は、2
- "ab"を作れる場合の数は、1
- "abc"を作れる場合の数は、1

表にすると

|     | a   | b   | c   | a   | b   | c   |
| --: | --- | --- | --- | --- | --- | --- |
|   a | 1   | 1   | 1   | 2   | 2   | 2   |
|  ab | 0   | 1   | 1   | 1   | 3   | 3   |
| abc | 0   | 0   | 1   | 1   | 1   | 4   |

のようになる。
次のような式が成り立つ

```
S[i]!=T[j]:　dp[i][j] = dp[i-1][j]
S[i]==T[j]:　dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
```

このように、漸化式が成り立ち、i-1 番目の結果を使って、i 番目の値を求めて、回帰的に i 番目の値を求めていくアルゴリズムを、動的計画法（dynamic programing）という

# DP に強くなるために

下記のコンテストの問題を解くといい

- https://atcoder.jp/contests/tdpc/tasks
- https://atcoder.jp/contests/dp/tasks

# Tips

- 番兵を追加すると、実装が楽になる
